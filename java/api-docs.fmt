[#ftl]

[#-- ============================================================================================== --]
[#-- File modified from the standard Enunciate FreeMarker template: --]
[#-- https://github.com/stoicflame/enunciate/blob/master/docs/src/main/resources/org/codehaus/enunciate/modules/docs/docs.fmt --]
[#-- ============================================================================================== --]

[#assign soapAvailable=docsxml.soap.wsdls.wsdl.endpointInterface?size > 0/]
[#assign restAvailable=docsxml.rest.resources.resource?size > 0/]
[#assign apiRelativePath="../.."/]
[#function scrubPathToFilename path]
  [#return "path_" + path?string?replace("/", "_")?replace(":","-")?replace("{", "-")?replace("}", "-") + ".html"/]
[/#function]
[#function tocNeeded(nodelist)]
  [#return nodelist?size > 2/]
[/#function]
[#function attributeExists(node)]
  [#if node?size??]
    [#--if there is a 'size' property, then it's not an attribute--]
    [#return node?size > 0/]
  [#else]
    [#return node?node_type = "attribute"/]
  [/#if]
[/#function]
[#function isDeprecated element]
  [#list element.tag as tag]
    [#if tag.@name="deprecated"]
      [#return true/]
    [/#if]
  [/#list]
  [#return false/]
[/#function]

[#--set up the subnavigation menus--]
[#assign nav_sections = { "Data Model" : "model.html"} /]
[#if soapAvailable]
  [#assign nav_sections = nav_sections + { "SOAP" : "soap.html" }/]
[/#if]
[#if restAvailable]
  [#assign nav_sections = nav_sections + { "REST" : "rest.html" }/]
[/#if]
[#if downloadsxml??]
  [#assign nav_sections = nav_sections + { "Files and Libraries" : "downloads.html"} /]
[/#if]

[#assign nav_resource_groups = {}/]
[#list docsxml.rest.groups.group?sort as group]
  [#assign nav_resource_groups = nav_resource_groups + { group : "resource_" + group + ".html"}/]
[/#list]

[#assign nav_paths = {}/]
[#list docsxml.rest.resources.resource?sort_by("@name") as resource]
  [#assign nav_paths = nav_paths + {resource.@name?string : scrubPathToFilename(resource.@name)}/]
[/#list]

[#assign nav_wsdls = {}/]
[#assign nav_eis_by_ns = {}/]
[#list docsxml.soap.wsdls.wsdl as wsdl]
  [#assign nav_wsdls = nav_wsdls + {wsdl.@namespaceId?string : "soap_" + wsdl.@namespaceId?string + ".html"}/]
  [#assign nav_eis_by_ns = nav_eis_by_ns + {wsdl.@namespaceId?string : {}}/]
  [#list wsdl.endpointInterface?sort_by("@name") as endpointInterface]
    [#assign tmp = nav_eis_by_ns[wsdl.@namespaceId?string] + {endpointInterface.@name?string : "soap_" + wsdl.@namespaceId?string + "_" + endpointInterface.@name?string + ".html"}/]
    [#assign nav_eis_by_ns = nav_eis_by_ns + {wsdl.@namespaceId?string : tmp}/]
  [/#list]
[/#list]

[#assign nav_models = {}/]
[#assign nav_typedefs_by_ns = {}/]
[#assign nav_elements_by_ns = {}/]
[#list docsxml.data.schema as schema]
  [#assign nav_models = nav_models + {schema.@namespaceId?string : schema.@namespaceId?string + ".html"}/]
  [#assign nav_elements_by_ns = nav_elements_by_ns + {schema.@namespaceId?string : {}}/]
  [#list schema.elements.element?sort_by("@name") as element]
    [#assign tmp = nav_elements_by_ns[schema.@namespaceId?string] + { element.@name?string + " element" : "el_" + schema.@namespaceId?string + "_" + element.@name?string + ".html"}/]
    [#assign nav_elements_by_ns = nav_elements_by_ns + {schema.@namespaceId?string : tmp}/]
  [/#list]
  [#assign nav_typedefs_by_ns = nav_typedefs_by_ns + {schema.@namespaceId?string : {}}/]
  [#list schema.types.type?sort_by("@name") as type]
    [#assign tmp = nav_typedefs_by_ns[schema.@namespaceId?string] + {type.@name?string : schema.@namespaceId?string + "_" + type.@name?string + ".html"}/]
    [#assign nav_typedefs_by_ns = nav_typedefs_by_ns + {schema.@namespaceId?string : tmp}/]
  [/#list]
[/#list]

[#macro boilerplate title=docsxml.@title!"Web API" subnav=[{"title" : "Home", "href" : indexPageName}] codeblocks=false]
<!doctype html>
<!-- paulirish.com/2008/conditional-stylesheets-vs-css-hacks-answer-neither/ -->
<!--[if lt IE 7 ]> <html class="no-js ie6" lang="en"> <![endif]-->
<!--[if IE 7 ]>    <html class="no-js ie7" lang="en"> <![endif]-->
<!--[if IE 8 ]>    <html class="no-js ie8" lang="en"> <![endif]-->
<!--[if (gte IE 9)|!(IE)]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
<head>
  <meta charset="utf-8">

  <!-- Always force latest IE rendering engine (even in intranet) & Chrome Frame
       Remove this if you use the .htaccess -->
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

  <title>${title}</title>

  <!-- Mobile viewport optimized: j.mp/bplateviewport -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- CSS: implied media="all" -->
  <link rel="stylesheet" href="css/style.css?v=2">
  <link rel="stylesheet" href="css/prettify.css">

  <!-- All JavaScript at the bottom, except for Modernizr which enables HTML5 elements & feature detects -->
  <script src="js/libs/modernizr-1.7.min.js"></script>

</head>

<body class="home">

  <div class="container">
    <header>
      <div id="header" class="column first last span-20">
        <div id="site-name" class="column span-18 append-1 prepend-1 first last"><a href="${indexPageName}">${title}</a></div>
        <div id="primary" class="column span-18 append-1 prepend-1 first last">
          <ul class="navigation">
            [#if soapAvailable]
            <li id="nav-soap"><a href="soap.html">SOAP</a></li>
            [/#if]
            [#if restAvailable]
            <li id="nav-rest"><a href="rest.html">REST</a></li>
            [/#if]
            <li id="nav-data"><a href="model.html">Data Model</a></li>
            [#if downloadsxml??]
            <li id="nav-downloads"><a href="downloads.html">Files and Libraries</a></li>
            [/#if]
          </ul>
        </div>
        <div>
          <ul class="xbreadcrumbs" id="breadcrumbs">
          [#list subnav as crumb]
            <li[#if !crumb_has_next] class="current"[/#if]>
              <a href="${crumb.href}"[#if crumb_index = 0] class="home"[/#if]>${crumb.title}</a>[#if crumb_has_next] &gt;[/#if]
              [#if crumb.subnav??]
              <ul>
                [#list crumb.subnav?keys as label]
                <li><a href="${crumb.subnav[label]}">${label}</a></li>
                [/#list]
              </ul>
              [/#if]
            </li>
          [/#list]
          </ul>
        </div>
      </div>
    </header>
    <div id="main" class="column first last span-20">
      [#nested/]

      <div class="clear"></div>
    </div>
    <footer>
      <div id="footer">
        [#if attributeExists(docsxml.@copyright)]
        Copyright &copy; <script type="text/javascript">d = new Date;document.write(d.getFullYear());</script> <span>${docsxml.@copyright}</span><br/>
        [/#if]
        Generated by <a href="http://enunciate.codehaus.org">Enunciate</a>.
      </div>
    </footer>
  </div> <!--! end of #container -->

  <!-- JavaScript at the bottom for fast page loading -->

  <!-- Grab Google CDN's jQuery, with a protocol relative URL; fall back to local if necessary -->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.js"></script>
  <script>window.jQuery || document.write("<script src='/static/ext/jquery/js/jquery-2.1.1.min.js'>\x3C/script>")</script>

  <!--manage the navigation menu-->
  <script src="js/libs/xbreadcrumbs.js"></script>
  <script>
    $(function() {
      $('#breadcrumbs').xBreadcrumbs();
    });
  </script>

  [#if codeblocks]

  <!-- prettify code blocks. see http://code.google.com/p/google-code-prettify/ -->
  <script src="js/libs/prettify/prettify.js"></script>
  <script>
    $(function() {
      prettyPrint();
    });
  </script>

  [/#if]
  <!--[if lt IE 7 ]>
    <script src="js/libs/dd_belatedpng.js"></script>
    <script>DD_belatedPNG.fix("img, .png_bg"); // Fix any <img> or .png_bg bg-images. Also, please read goo.gl/mZiyb </script>
  <![endif]-->

[#--
  todo: uncomment to support google analytics measurements...
  <!-- mathiasbynens.be/notes/async-analytics-snippet Change UA-XXXXX-X to be your site's ID -->
  <script>
    var _gaq=[["_setAccount","UA-XXXXX-X"],["_trackPageview"]];
    (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];g.async=1;
    g.src=("https:"==location.protocol?"//ssl":"//www")+".google-analytics.com/ga.js";
    s.parentNode.insertBefore(g,s)}(document,"script"));
  </script>
--]
</body>
</html>
[/#macro]
[@file name=indexPageName charset="utf-8"]
  [@boilerplate]
    [#if docsxml.documentation?size > 0]
      <h1>Introduction</h1>

      <p>${docsxml.documentation}</p>

    [/#if]

    [#if restAvailable]

      <p>HTTP requests should set the "Content-Type" header to "application/json"
      for most calls, unless specified otherwise.</p>

      <h3>Authentication</h3>
      <p>
        The Cloudera Manager API uses <a href="http://tools.ietf.org/html/rfc2617">HTTP
        basic access authentication</a>. It accepts the same user credentials
        as the web interface. Different users may have different levels of access,
        as defined by their roles. (See the user management API calls for more.)
        With every authenticated request, the server returns a session cookie,
        which can be subsequently used for authentication.
      </p>

      <h3>Error Code</h3>
      <p>The API returns HTTP code in the 400s and 500s upon errors:
      <ul>
        <li>400 &mdash; Invalid request parameters; Malformed requests</li>
        <li>401 &mdash; Authentication failure</li>
        <li>403 &mdash; Authorization failure</li>
        <li>404 &mdash; Object not found</li>
        <li>500 &mdash; Internal API error</li>
        <li>503 &mdash; Response temporarily unavailable; caller should retry later</li>
      </ul>
      <p>See <a href="path__tools_echoError.html">/tools/echoError</a> for a
      discussion on the body of an error response.<p>

      <h1>API Usage Tutorial</h1>
      <p><a href="tutorial.html">Tutorial link.</a></p>

      <h1>API Version</h1>
      <p>
        The API can be queried for the latest version it supports. By
        making a GET request to the '/version' URL, a string will be
        returned with the highest supported version (for example, "v2").
      </p>
      <p>
        Note that servers that only support API v1 do not support this
        call. In that case, a 404 error will be returned, and can be
        used to detect that the server only supports v1.
      </p>
      <p>
        The version should be prepended to the path of the REST resources
        listed below. The documentation of the different resources lists
        the version which added the particular functionality.
      </p>

      <h1>REST Resources</h1>
      <p>
        This API supports a <a href="http://en.wikipedia.org/wiki/Representational_State_Transfer">Representational State Transfer (REST)</a>
        model for accessing a set of resources through a fixed set of operations. The following resources are accessible through the RESTful model:
      </p>
      <ul>
      [#if ((groupRestResources!"byDocumentationGroup") != "byPath") && docsxml.rest.groups.group?size > 0]
        [#list docsxml.rest.groups.group?sort as group]
          [@processResourceGroup group=group/]
        <li><a href="resource_${group}.html">${group}</a></li>
        [/#list]
      [#else]
        [#list docsxml.rest.resources.resource?sort_by("@name") as resource]
          [@processResource resource=resource/]
        <li><a href="${scrubPathToFilename(resource.@name)}">${resource.@name}</a></li>
        [/#list]
      [/#if]
      </ul>
      [#if attributeExists(docsxml.rest.@wadl)]
      <p>
        There is also a <a href="${docsxml.rest.@wadl}">WADL document</a> describing the REST API.
      </p>
      [/#if]
    [/#if]
    [#if soapAvailable]

      <h1>SOAP Endpoints</h1>
      <p>
        This API is exposed through a set of <a href="http://www.ws-i.org/Profiles/BasicProfile-1.0.html">WSI Basic Profile</a>
        -compliant SOAP v1.1 endpoints. The API supports <a href="http://www.w3.org/TR/2005/REC-xop10-20050125/">XML-binary Optimized Pacakging (XOP)</a>
        and <a href="http://www.w3.org/TR/2004/WD-soap12-mtom-20040608/">SOAP Message Transmission Optimization Mechanism (MTOM)</a>
        for transmission of binary data. The SOAP API is described by the following endpoints:
      </p>
      [#list docsxml.soap.wsdls.wsdl as wsdl]
        [@processWsdl wsdl=wsdl/]
      <h2>Namespace "${wsdl.@namespaceId}"</h2>
      <table>
        <tr>
          <td align="right">Namespace URI:</td>
          <td>[#if wsdl.@namespace?length > 0]${wsdl.@namespace}[#else](default namespace)[/#if]</td>
        </tr>
        [#if attributeExists(wsdl.@file)]
        <tr>
          <td align="right">WSDL:</td>
          <td><a href="${wsdl.@file}">${wsdl.@file}</a></td>
        </tr>
        [/#if]
      </table>
      <h3>Endpoints</h3>
      <ul>
      [#list wsdl.endpointInterface?sort_by("@name") as endpointInterface]
        [@processEndpointInterface endpointInterface=endpointInterface/]
        <li[#if isDeprecated(endpointInterface)] class="deprecated"[/#if]><a href="soap_${wsdl.@namespaceId}_${endpointInterface.@name}.html">${endpointInterface.@name}</a></li>
      [/#list]
      </ul>
      [/#list]
      [#if downloadsxml??]
      <p>
        The SOAP API is also accessible by a set of client-side libraries that can be downloaded from the <a href="downloads.html">files and libraries page</a>.
      </p>
      [/#if]
    [/#if]

    <h1>Data Model</h1>

    <p>
      All endpoints act on a common set of data. The Cloudera Manager API uses <a href="http://json.org">JSON</a>.
    </p>

    [#list docsxml.data.schema as schema]
      [@processSchema schema=schema/]

      [#if schema.elements.element?size > 0]

        <h3>Data Elements</h3>

        <ul>
        [#list schema.elements.element?sort_by("@name") as element]
          <li[#if isDeprecated(element)] class="deprecated"[/#if]><a href="el_${schema.@namespaceId}_${element.@name}.html">${element.@name}</a></li>
        [/#list]
        </ul>
      [/#if]
    [/#list]
    [#if docsxml.data.jsonSchema.type?size > 0]

      <h1>JSON Data Types</h1>
      <ul>
      [#list docsxml.data.jsonSchema.type as type]
        [@processJsonType type=type/]
        <li[#if isDeprecated(type)] class="deprecated"[/#if]><a href="json_" + type?parent.@schemaId + "_" + type.@name + ".html">${type.@name}</a></li>
      [/#list]
      </ul>
    [/#if]
  [/@boilerplate]
[/@file]
[@file name="model.html" charset="utf-8"]
  [@boilerplate title="Data Model" subnav=[{"title" : "Home", "href" : indexPageName}, {"title" : "Data Model" , "href" : "model.html", "subnav" : nav_sections}]]
    <h1>Data Model</h1>

    <p>
      All endpoints act on a common set of data. The Cloudera Manager API uses <a href="http://json.org">JSON</a>.
    </p>

    [#list docsxml.data.schema as schema]

      [#if schema.elements.element?size > 0]

    <h3>Data Elements</h3>

    <ul>
      [#list schema.elements.element?sort_by("@name") as element]
      <li[#if isDeprecated(element)] class="deprecated"[/#if]><a href="el_${schema.@namespaceId}_${element.@name}.html">${element.@name}</a></li>
      [/#list]
    </ul>
      [/#if]
    [/#list]
  [/@boilerplate]
[/@file]
[#if downloadsxml??]
  [@file name="downloads.html" charset="utf-8"]
    [@boilerplate title="Files and Libraries" subnav=[{"title" : "Home", "href" : indexPageName}, { "title" : "Files and Libraries" , "href" : "downloads.html" , "subnav" : nav_sections}] codeblocks=true]
  <h1>Files and Libraries</h1>

  <p>The following files and libraries are available:</p>

  <h3>Client Library</h3>
  <ul>
    <li><a href="https://github.com/cloudera/cm_api">https://github.com/cloudera/cm_api</a></li>
  </ul>

  <ul>
      [#list downloadsxml.download as download]
    <li><a href="#${download.@name}">${download.@name}</a></li>
      [/#list]
  </ul>
      [#list downloadsxml.download as download]
  <a name="${download.@name}"></a>
  <h2>${download.@name}</h2>
        [#list download.created as created]
  <p class="note">Created ${created}</p>
        [/#list]
        [#list download.description as description]
  <p>${description}</p>
        [/#list]
  <h3>Files</h3>
  <table>
    <tr>
      <th>name</th>
      <th>size</th>
        [#if download.files.file?size > 1]
      <th>description</th>
        [/#if]
    </tr>
        [#list download.files.file as file]
    <tr>
      <td><a href="${file.@name}">${file.@name}</a></td>
      <td>${file.@size}</td>
          [#if file_index > 0 || file_has_next]
      <td>${file}</td>
          [/#if]
    </tr>
        [/#list]
  </table>
      [/#list]
    [/@boilerplate]
  [/@file]
[/#if]
[#if restAvailable]
  [@file name="rest.html" charset="utf-8"]
    [@boilerplate title="REST" subnav=[{"title" : "Home", "href" : indexPageName}, {"title" : "REST" , "href" : "rest.html", "subnav" : nav_sections}]]
  <h1>REST Resources</h1>
  <p>
    This API supports a <a href="http://en.wikipedia.org/wiki/Representational_State_Transfer">Representational State Transfer (REST)</a>
    model for accessing a set of resources through a fixed set of operations. The following resources are accessible through the RESTful model:
  </p>
  <ul>
    [#if ((groupRestResources!"byDocumentationGroup") != "byPath") && docsxml.rest.groups.group?size > 0]
      [#list docsxml.rest.groups.group?sort as group]
      <li><a href="resource_${group}.html">${group}</a></li>
      [/#list]
    [#else]
      [#list docsxml.rest.resources.resource?sort_by("@name") as resource]
      <li><a href="${scrubPathToFilename(resource.@name)}">${resource.@name}</a></li>
      [/#list]
    [/#if]
  </ul>
      [#if attributeExists(docsxml.rest.@wadl)]
  <p>
    There is also a <a href="${docsxml.rest.@wadl}">WADL document</a> describing the REST API.
  </p>
      [/#if]
    [/@boilerplate]
  [/@file]
[/#if]
[#if soapAvailable]
  [@file name="soap.html" charset="utf-8"]
    [@boilerplate title="SOAP" subnav=[{"title" : "Home", "href" : indexPageName}, {"title" : "SOAP" , "href" : "soap.html", "subnav" : nav_sections}]]
  <h1>SOAP Endpoints</h1>
  <p>
    This API is exposed through a set of <a href="http://www.ws-i.org/Profiles/BasicProfile-1.0.html">WSI Basic Profile</a>
    -compliant SOAP v1.1 endpoints. The API supports <a href="http://www.w3.org/TR/2005/REC-xop10-20050125/">XML-binary Optimized Pacakging (XOP)</a>
    and <a href="http://www.w3.org/TR/2004/WD-soap12-mtom-20040608/">SOAP Message Transmission Optimization Mechanism (MTOM)</a>
    for transmission of binary data. The SOAP API is fully described by the following endpoints:
  </p>
      [#list docsxml.soap.wsdls.wsdl as wsdl]
  <h2>Namespace "${wsdl.@namespaceId}"</h2>
  <table>
    <tr>
      <td align="right">Namespace URI:</td>
      <td>[#if wsdl.@namespace?length > 0]${wsdl.@namespace}[#else](default namespace)[/#if]</td>
    </tr>
        [#if attributeExists(wsdl.@file)]
    <tr>
      <td align="right">WSDL:</td>
      <td><a href="${wsdl.@file}">${wsdl.@file}</a></td>
    </tr>
        [/#if]
  </table>
  <h3>Endpoints</h3>
  <ul>
      [#list wsdl.endpointInterface?sort_by("@name") as endpointInterface]
    <li[#if isDeprecated(endpointInterface)] class="deprecated"[/#if]><a href="soap_${wsdl.@namespaceId}_${endpointInterface.@name}.html">${endpointInterface.@name}</a></li>
      [/#list]
  </ul>
      [/#list]
      [#if downloadsxml??]
  <p>
    The SOAP API is also accessible by a set of client-side libraries that can be downloaded from the <a href="downloads.html">files and libraries page</a>.
  </p>
      [/#if]
    [/@boilerplate]
  [/@file]
[/#if]
[#macro processWsdl wsdl]
  [@file name="soap_" + wsdl.@namespaceId + ".html" charset="utf-8"]
    [@boilerplate title="SOAP: " + wsdl.@namespaceId subnav=[{"title" : "Home", "href" : indexPageName}, {"title" : "SOAP" , "href" : "soap.html", "subnav" : nav_sections }, { "title" : wsdl.@namespaceId?string , "href" : "soap_" + wsdl.@namespaceId + ".html" }]]
  <h1>${wsdl.@namespaceId}</h1>
  <table>
    <tr>
      <td align="right">Namespace URI:</td>
      <td>[#if wsdl.@namespace?length > 0]${wsdl.@namespace}[#else](default namespace)[/#if]</td>
    </tr>
        [#if attributeExists(wsdl.@file)]
    <tr>
      <td align="right">WSDL:</td>
      <td><a href="${wsdl.@file}">${wsdl.@file}</a></td>
    </tr>
        [/#if]
  </table>
  <h3>Endpoints</h3>
  <ul>
      [#list wsdl.endpointInterface?sort_by("@name") as endpointInterface]
    <li[#if isDeprecated(endpointInterface)] class="deprecated"[/#if]><a href="soap_${wsdl.@namespaceId}_${endpointInterface.@name}.html">${endpointInterface.@name}</a></li>
      [/#list]
  </ul>
    [/@boilerplate]
  [/@file]
[/#macro]
[#macro processResourceGroup group]
  [@file name="resource_" + group + ".html" charset="utf-8"]
    [@boilerplate title=group subnav=[{"title" : "Home", "href" : indexPageName}, {"title" : "REST" , "href" : "rest.html", "subnav" : nav_sections}, {"title" : group , "href" : "resource_" + group + ".html", "subnav" : nav_resource_groups}]]
      <h1>${group}</h1>

      [#assign resources=[] /]
      [#list docsxml.rest.resources.resource as resource]
        [#list resource.groups.group as rg]
          [#if rg = group]
            [#assign resources=resources + resource /]
            [#break/]
          [/#if]
        [/#list]
      [/#list]
      <p>The following resources are part of this group:</p>
      <ul>
        [#list resources as resource]
        <li><a href="#${scrubPathToFilename(resource.@name)}">${resource.@name}</a></li>
        [/#list]
      </ul>
      [#list resources as resource]
      <a name="${scrubPathToFilename(resource.@name)}"></a>
        [@processRawResource resource=resource/]
      [/#list]
    [/@boilerplate]
  [/@file]
[/#macro]
[#macro processResource resource]
  [#assign resource_filename=scrubPathToFilename(resource.@name)/]
  [@file name=resource_filename charset="utf-8"]
    [@boilerplate title=group subnav=[{"title" : "Home", "href" : indexPageName}, { "title" : "REST" , "href" : "rest.html", "subnav" : nav_sections }, {"title" : resource.@name , "href" : resource_filename, "subnav" : nav_paths}]]
      [@processRawResource resource=resource/]
    [/@boilerplate]
  [/@file]
[/#macro]
[#macro processRawResource resource]
      <h1>${resource.@name}</h1>
  [#if attributeExists(resource.@subcontext) && !disableRestMountpoint!false]
      <p class="note">Mount Point: <a href="${apiRelativePath}${resource.@subcontext}${resource.@name}">${resource.@subcontext}${resource.@name}</a></p>
  [/#if]
  [#if tocNeeded(resource.operation)]
      <p>
        The following operations are supported on this resource:
      </p>
      <ul>
    [#list resource.operation as operation]
        <li[#if isDeprecated(operation)] class="deprecated"[/#if]><a href="#${operation.@name}">${operation.@name}</a></li>
      [#list operation.alias as alias]
        <li[#if isDeprecated(operation)] class="deprecated"[/#if]><a href="#${operation.@name}">${alias}</a></li>
      [/#list]
    [/#list]
      </ul>
  [/#if]
  [#list resource.operation as operation]
      <a name="${operation.@name}"></a>
      <h2>${operation.@name}</h2>
    [#list operation.alias as alias]
      <p class="note">Alias: ${alias}</p>
    [/#list]
    [#if isDeprecated(operation)]
      <p class="alert">This operation has been deprecated. [#list operation.tag as tag][#if tag.@name="deprecated"] ${tag}[/#if][/#list]</p>
    [/#if]
    [#list operation.documentation as documentation]
      <p>${documentation}</p>
    [/#list]
    [#list operation.parameter as parameter]
      [#if parameter_index = 0]
      <h3>Parameters</h3>
      <table>
        <tr>
          <th>name</th>
          <th>description</th>
          <th>type</th>
          <th>default</th>
        </tr>
      [/#if]
        <tr>
          <td>[#if attributeExists(parameter.@name)]${parameter.@name}[/#if]</td>
          <td>${parameter}</td>
          <td>[#if attributeExists(parameter.@type)]${parameter.@type}[/#if]</td>
          <td>[#if attributeExists(parameter.@defaultValue)]${parameter.@defaultValue}[/#if]</td>
        </tr>
      [#if !parameter_has_next]
      </table>
      [/#if]
    [/#list]
    [#list operation.inValue as inValue]
      <h3>Request Body</h3>
      <table>
      [#assign custom=true]
      [#list inValue.xmlElement as xmlElement]
        [#if attributeExists(xmlElement.@elementName)]
          [#assign custom=false/]
        <tr>
          <td align="right">element:</td>
          [#if attributeExists(xmlElement.@elementSchemaId)]
          <td><a href="el_${xmlElement.@elementSchemaId}_${xmlElement.@elementName}.html">${xmlElement.@elementName}</a></td>
          [#else]
          <td>${xmlElement.@elementName}</td>
          [/#if]
        </tr>
        [/#if]
      [/#list]
      [#list inValue.jsonElement as jsonElement]
        [#if attributeExists(jsonElement.@elementName)]
          [#assign custom=false/]
        <tr>
          <td align="right">element:</td>
          [#if attributeExists(jsonElement.@elementSchemaId)]
          <td><a href="json_${jsonElement.@elementSchemaId}_${jsonElement.@elementName}.html">${jsonElement.@elementName}</a></td>
          [#else]
          <td>${jsonElement.@elementName}</td>
          [/#if]
        </tr>
        [/#if]
      [/#list]
      [#if custom]
        <tr>
          <td align="right">element:</td>
          <td>(custom)</td>
        </tr>
      [/#if]
      [#list inValue["contentType[consumable='true']"] as contentType]
        <tr>
          <td align="right">consumable media type:</td>
          <td>${contentType.@type}</td>
        </tr>
      [/#list]
      </table>
      [#list inValue.documentation as documentation]
      <p>${documentation}</p>
      [/#list]
    [/#list]
    [#list operation.outValue as outValue]
      <h3>Response Body</h3>
      <table>
      [#assign custom=true]
      [#list outValue.xmlElement as xmlElement]
        [#if attributeExists(xmlElement.@elementName)]
          [#assign custom=false/]
        <tr>
          <td align="right">element:</td>
          [#if attributeExists(xmlElement.@elementSchemaId)]
          <td><a href="el_${xmlElement.@elementSchemaId}_${xmlElement.@elementName}.html">${xmlElement.@elementName}</a></td>
          [#else]
          <td>${xmlElement.@elementName}</td>
          [/#if]
        </tr>
        [/#if]
      [/#list]
      [#list outValue.jsonElement as jsonElement]
        [#if attributeExists(jsonElement.@elementName)]
          [#assign custom=false/]
        <tr>
          <td align="right">element:</td>
          [#if attributeExists(jsonElement.@elementSchemaId)]
          <td><a href="json_${jsonElement.@elementSchemaId}_${jsonElement.@elementName}.html">${jsonElement.@elementName}</a></td>
          [#else]
          <td>${jsonElement.@elementName}</td>
          [/#if]
        </tr>
        [/#if]
      [/#list]
      [#if custom]
        <tr>
          <td align="right">element:</td>
          <td>(custom)</td>
        </tr>
      [/#if]
      [#list outValue["contentType[produceable='true']"] as contentType]
        <tr>
          <td align="right">produceable media type:</td>
          <td>${contentType.@type}</td>
        </tr>
      [/#list]
      </table>
      [#list outValue.documentation as documentation]
      <p>${documentation}</p>
      [/#list]
    [/#list]
    [#list operation.statusCode as statusCode]
      [#if statusCode_index = 0]
      <h3>Status Codes</h3>
      <table>
        <tr>
          <th>code</th>
          <th>description</th>
        </tr>
      [/#if]
        <tr>
          <td>${statusCode.@code}</td>
          <td>${statusCode}</td>
        </tr>
      [#if !statusCode_has_next]
      </table>
      [/#if]
    [/#list]
  [/#list]
[/#macro]
[#macro processEndpointInterface endpointInterface]
  [@file name="soap_" + endpointInterface?parent.@namespaceId + "_" + endpointInterface.@name + ".html" charset="utf-8"]
    [@boilerplate title=endpointInterface.@name subnav=[{"title" : "Home", "href" : indexPageName}, {"title" : "SOAP" , "href" : "soap.html", "subnav" : nav_sections }, {"title" : endpointInterface?parent.@namespaceId , "href" : "soap_" + endpointInterface?parent.@namespaceId + ".html", "subnav" : nav_wsdls }, {"title" : endpointInterface.@name , "href" : "soap_" + endpointInterface.@name + ".html", "subnav" : nav_eis_by_ns[endpointInterface?parent.@namespaceId?string]}]]
      <h1>${endpointInterface.@name}</h1>
      [#if isDeprecated(endpointInterface)]
      <p class="alert">This endpoint has been deprecated.[#list endpointInterface.tag as tag][#if tag.@name="deprecated"] ${tag}[/#if][/#list]</p>
      [/#if]
      <table>
        <tr>
          <td align="right">Namespace:</td>
          <td>[#if (endpointInterface?parent).@namespace?length > 0]${(endpointInterface?parent).@namespace}[#else](default namespace)[/#if]</td>
        </tr>
        [#if attributeExists((endpointInterface?parent).@file)]
        <tr>
          <td align="right">WSDL:</td>
          <td><a href="${(endpointInterface?parent).@file}">${(endpointInterface?parent).@file}</a></td>
        </tr>
        [/#if]
        [#if attributeExists(endpointInterface.@path)]
          <tr>
            <td align="right">Path:</td>
            <td><a href="${apiRelativePath}${endpointInterface.@path}">${endpointInterface.@path}</a></td>
          </tr>
        [/#if]
      </table>
      [#if endpointInterface.documentation?size > 0]
        [#list endpointInterface.documentation as documentation]
      <p>${documentation}</p>
        [/#list]
      [/#if]
      [#if tocNeeded(endpointInterface.method)]
      <p>
        The following methods are available on this endpoint:
      </p>
      <ul>
        [#list endpointInterface.method as method]
        <li[#if isDeprecated(method)] class="deprecated"[/#if]><a href="#${method.@name}">${method.@name}</a></li>
        [/#list]
      </ul>
      [/#if]
      [#list endpointInterface.method as method]
      <a name="${method.@name}"></a>
      <h2>${method.@name}</h2>
        [#if isDeprecated(method)]
      <p class="alert">This method has been deprecated.[#list method.tag as tag][#if tag.@name="deprecated"] ${tag}[/#if][/#list]</p>
        [/#if]
        [#list method.documentation as documentation]
      <p>${documentation}</p>
        [/#list]
        [#list method["parameter[@input='true']"] as parameter]
          [#if parameter_index = 0]
      <h3>Input Parameters</h3>
      <table>
        <tr>
          <th>name</th>
          <!--todo: add the parameter type and whether its a collection-->
          <th>description</th>
        </tr>
          [/#if]
        <tr>
          <td>${parameter.@name}</td>
          <td>${parameter}</td>
        </tr>
          [#if !parameter_has_next]
      </table>
          [/#if]
        [/#list]
        [#list method["parameter[@output='true']"] as parameter]
          [#if parameter_index = 0]
      <h3>Output Parameters</h3>
      <table>
        <tr>
          <th>name</th>
          <!--todo: add the parameter type and whether its a collection-->
          <th>description</th>
        </tr>
          [/#if]
        <tr>
          <td>${parameter.@name}</td>
          <td>${parameter}</td>
        </tr>
          [#if !parameter_has_next]
      </table>
          [/#if]
        [/#list]
        [#list method.result as result]
      <h3>Return Value</h3>

      <p>${result}</p>
        [/#list]
        [#list method.fault as fault]
          [#if fault_index = 0]
      <h3>Faults</h3>
      <table>
        <tr>
          <th>name</th>
          <!--todo: add the parameter type and whether its a collection-->
          <th>description</th>
        </tr>
          [/#if]
        <tr>
          <td>${fault.@name}</td>
          <td>${fault}</td>
        </tr>
          [#if !fault_has_next]
      </table>
          [/#if]
        [/#list]
      [/#list]
    [/@boilerplate]
  [/@file]
[/#macro]
[#macro processSchema schema]
  [@file name=schema.@namespaceId + ".html" charset="utf-8"]
    [@boilerplate title="Namespace" subnav=[{"title" : "Home", "href" : indexPageName}, {"title" : "Data Model" , "href" : "model.html", "subnav" : nav_sections}, {"title" : schema.@namespaceId , "href" : schema.@namespaceId + ".html", "subnav" : nav_models}]]
      [#if schema.elements.element?size > 0]

      <h2>Elements</h2>

      <ul>
        [#list schema.elements.element?sort_by("@name") as element]
        [@processElement element=element/]
        <li[#if isDeprecated(element)] class="deprecated"[/#if]><a href="el_${schema.@namespaceId}_${element.@name}.html">${element.@name}</a></li>
        [/#list]
      </ul>
      [/#if]
      [#if schema.types.type?size > 0]

      <h2>Types</h2>

      <ul>
        [#list schema.types.type?sort_by("@name") as type]
        [@processType type=type/]
        <li[#if isDeprecated(type)] class="deprecated"[/#if]><a href="${schema.@namespaceId}_${type.@name}.html">${type.@name}</a></li>
        [/#list]
      </ul>
      [/#if]
    [/@boilerplate]
  [/@file]
[/#macro]
[#macro processElement element]
  [#assign schema=element?parent?parent/]
  [@file name="el_" + schema.@namespaceId + "_" + element.@name + ".html" charset="utf-8"]
    [@boilerplate title=element.@name subnav=[{"title" : "Home", "href" : indexPageName}, {"title" : "Data Model" , "href" : "model.html", "subnav" : nav_sections}, {"title" : schema.@namespaceId , "href" : schema.@namespaceId + ".html", "subnav" : nav_models}, {"title" : element.@name + " element" , "href" : "el_" + schema.@namespaceId + "_" + element.@name + ".html", "subnav" : nav_elements_by_ns[schema.@namespaceId?string]}] codeblocks=true]
      <h1>${element.@name} element</h1>
      [#if isDeprecated(element)]
      <p class="alert">This element has been deprecated.[#list element.tag as tag][#if tag.@name="deprecated"] ${tag}[/#if][/#list]</p>
      [/#if]
      <table>
      [#if attributeExists(element.@typeName) && attributeExists(element.@typeSchemaId)]
        <tr>
          <td align="right">Type:</td>
          <td><a href="${element.@typeSchemaId}_${element.@typeName}.html">${element.@typeName}</a></td>
        </tr>
      [/#if]
      </table>
      [#list element.documentation as documentation]
      <p>${documentation}</p>
      [/#list]
      [#list element.examplexml as examplexml]
      <h2>Example XML</h2>
      <code class="prettyprint lang-xml">${examplexml?string?xhtml}</code>
      [/#list]
      [#list element.examplejson as examplejson]
      <h2>Example JSON</h2>
      <code class="prettyprint lang-js">${examplejson?string?xhtml}</code>
      [/#list]
    [/@boilerplate]
  [/@file]
[/#macro]
[#macro processType type]
  [#assign schema=type?parent?parent/]
  [@file name=schema.@namespaceId + "_" + type.@name + ".html" charset="utf-8"]
    [@boilerplate title=type.@name subnav=[{"title" : "Home", "href" : indexPageName}, {"title" : "Data Model" , "href" : "model.html", "subnav" : nav_sections}, {"title" : schema.@namespaceId , "href" : schema.@namespaceId + ".html", "subnav" : nav_models} , {"title" : type.@name , "href" : schema.@namespaceId + "_" + type.@name + ".html", "subnav" : nav_typedefs_by_ns[schema.@namespaceId?string]}] codeblocks=true]
      <h1>${type.@name}</h1>
      [#if isDeprecated(type)]
      <p class="alert">This type has been deprecated.[#list type.tag as tag][#if tag.@name="deprecated"] ${tag}[/#if][/#list]</p>
      [/#if]
      <table>
      [#if attributeExists(type.@extendsType)]
        [#list docsxml.data.schema.types.type as candidate]
          [#if attributeExists(candidate.@id) && (candidate.@id?string = type.@extendsType?string)]
        <tr>
          <td align="right">Extends:</td>
          <td><a href="${candidate?parent?parent.@namespaceId}_${candidate.@name}.html">${candidate.@name}</a></td>
        </tr>
            [#break/]
          [/#if]
        [/#list]
      [/#if]
      </table>
      [#list type.documentation as documentation]
      <p>${documentation}</p>
      [/#list]

      [#if type.values.item?size > 0]
        [#list type.values.item as value]
          [#if value_index = 0]
      <h2>Possible Values</h2>
      <table>
        <tr>
          <th>value</th>
          <th>description</th>
        </tr>
          [/#if]
        <tr>
          <td[#if isDeprecated(value)] class="deprecated"[/#if]>${value.@value}</td>
          <td>
          [#list value.documentation as documentation]
            ${documentation}
          [/#list]
          </td>
        </tr>
          [#if !value_has_next]
      </table>
          [/#if]
        [/#list]
      [#else]

      <h2>JSON</h2>
      <table>
        <tr>
          <th>property</th>
          <th>type</th>
          <th>description</th>
        </tr>
        [#list type.attributes.attribute as attribute]
        <tr>
          <td>[#if attributeExists(attribute.@jsonName)]${attribute.@jsonName}[/#if]</td>
          <td>[#if attributeExists(attribute.@typeSchemaId)][#if attributeExists(attribute.@typeName)][#assign typename=attribute.@typeName/][#else][#assign typename="(anonymous)"/][/#if]<a href="${attribute.@typeSchemaId}_${typename}.html">${typename}</a>[#elseif attributeExists(attribute.@typeName)]${attribute.@typeName}[/#if]</td>
          <td>${attribute}</td>
        </tr>
        [/#list]
        [#list type.elements.element as element]
        <tr>
          <td>[#if attributeExists(element.@jsonName)]${element.@jsonName}[/#if]</td>
          <td>
          [#list element.choice as choice]
            [#if element.@maxOccurs = "unbounded"]array of [/#if][#if choice_index > 0]<br/>or [/#if][#if attributeExists(choice.@schemaId)]<a href="el_${choice.@schemaId}_${choice.@name}.html">${choice.@name}</a>[#else]${choice.@name}[/#if][#if attributeExists(choice.@typeSchemaId)][#if attributeExists(choice.@typeName)][#assign typename=choice.@typeName/][#else][#assign typename="(anonymous)"/][/#if] (<a href="${choice.@typeSchemaId}_${typename}.html">${typename}</a>)[#elseif attributeExists(choice.@typeName)] (${choice.@typeName})[/#if]
          [/#list]
          </td>
          <td>
          [#list element.documentation as documentation]
            ${documentation}
          [/#list]
          </td>
        </tr>
        [/#list]
        [#list type.value as value]
        <tr>
          <td>[#if attributeExists(value.@jsonName)]${value.@jsonName}[/#if]</td>
          <td>[#if attributeExists(value.@typeSchemaId)][#if attributeExists(value.@typeName)][#assign typename=value.@typeName/][#else][#assign typename="(anonymous)"/][/#if]<a href="${value.@typeSchemaId}_${typename}.html">${typename}</a>[#elseif attributeExists(value.@typeName)]${value.@typeName}[/#if]</td>
          <td>${value}</td>
        </tr>
        [/#list]
      </table>
      [/#if]
    [/@boilerplate]
  [/@file]
[/#macro]
[#macro processJsonType type]
  [@file name="json_" + type?parent.@schemaId + "_" + type.@name + ".html" charset="utf-8"]
    [@boilerplate title=type.@name subnav=[{"title" : "Home", "href" : indexPageName}, {"title" : "JSON" , "href" : "#"}, {"title" : type.@name , "href" : "json_" + type?parent.@schemaId + "_" + type.@name + ".html"}] codeblocks=true]
      <h1>${type.@name}</h1>

      <table>
      [#if attributeExists(type?parent.@schemaId)]
      <tr>
        <td align="right">JSON Schema ID:</td>
        <td>${type?parent.@schemaId}</td>
      </tr>
      [/#if]
      [#if attributeExists(type?parent.@file)]
      <tr>
        <td align="right">JSON Schema File:</td>
        <td><a href="${type?parent.@file}">${type?parent.@file}</a></td>
      </tr>
      [/#if]
      </table>
      [#list type.documentation as documentation]
      <p>${documentation}</p>
      [/#list]
      [#list type.properties as property]
        [#if property_index = 0]
      <h2>Properties</h2>
      <table>
        <tr>
          <th>name</th>
          <th>type</th>
          <th>description</th>
        </tr>
        [/#if]
        <tr>
          <td>[#if attributeExists(property.@name)]${property.@name}[/#if]</td>
          <td>[#if property.@isList = "true"]List of [/#if][#if attributeExists(property.@typeSchemaId)][#if attributeExists(property.@typeName)][#assign typename=property.@typeName/][#else][#assign typename="(anonymous)"/][/#if]<a href="json_${property.@typeSchemaId}_${typename}.html">${typename}</a>[#elseif attributeExists(property.@typeName)]${property.@typeName}[/#if]</td>
          <td>[#if attributeExists(property.@documentation)]${property.@documentation}[/#if]</td>
        </tr>
        [#if !property_has_next]
      </table>
        [/#if]
      [/#list]
      [#list type.enumValue as enumValue]
        [#if enumValue_index = 0]
      <h2>Possible Values</h2>
      <table>
        <tr>
          <th>value</th>
          <th>description</th>
        </tr>
        [/#if]
        <tr>
          <td>[#list enumValue.value as value]${value} [/#list]</td>
          <td>[#list enumValue.documentation as documentation]${documentation} [/#list]</td>
        </tr>
        [#if !enumValue_has_next]
      </table>
        [/#if]
      [/#list]
    [/@boilerplate]
  [/@file]
[/#macro]
[@file name="tutorial.html" charset="utf-8"]
  [@boilerplate]
    <h1>API Usage Tutorial</h1>

    <h2>Cloudera Manager Concepts</h2>

    <p>The API terminology is similar to that used in the web UI:</p>
    <dl>
      <dt>Cluster</dt>
      <dd>
        <p>
        A cluster is a set of hosts running interdependent services.
        All services in a cluster have the same CDH version. A Cloudera
        Manager installation may have multiple clusters, which are uniquely
        identified by different names.
        <p>
        You can issue commands against a cluster.
      </dd>
      <dt>Service</dt>
      <dd>
        <p>
        A service is an abstract entity providing a capability in a cluster.
        Examples of services are HDFS, MapReduce, YARN, and HBase. A service
        is usually distributed, and contains a set of roles that physically
        run on the cluster. A service has its own configuration, status and
        roles.  You may issue commands against a service, or against a set
        of roles in bulk. Additionally, an HDFS service has nameservices,
        and a MapReduce service has activities.
        <p>
        All services belong to a cluster (except for the Cloudera Management
        Service), and is uniquely identified by its name within a Cloudera
        Manager installation. The types of services available depends on the
        CDH version of the cluster.
      </dd>
      <dt>Role</dt>
      <dd>
        <p>
        A role performs specific actions for a service, and is assigned to a
        host. It usually runs as a daemon process, such as a DataNode or a
        TaskTracker. (There are exceptions; not all roles are daemon
        processes.) Once created, a role cannot be reassigned to a different
        host. You need to delete and re-create it.
        <p>
        A role has its own configuration and status. API commands on roles
        are always issued in bulk at the service level.
      </dd>
      <dt>Role Type</dt>
      <dd>
        <p>
        Role type refers to the class that a role belongs to. For example, an
        HBase service has the Master role type and the RegionServer role type.
        Different service types have different sets of role types.  This is not
        to be confused with a role, which refers to a specific role instance
        that is physically assigned to a host.
        <p>
        You can specify configuration for a role type, which is inherited by all
        role instances of that type.
      </dd>
      <dt>Host</dt>
      <dd>
        <p>
        The Cloudera Manager Agent runs on hosts that are managed by Cloudera
        Manager. You can assign service roles to hosts.
      </dd>
      <dt>Cloudera Manager</dt>
      <dd>
        <p>
        Everything related to the operation of Cloudera Manager is available
        under the <kbd>/cm</kbd> resource. This includes global commands,
        system configuration, and the Cloudera Management Service.
      </dd>
      <dt>Cloudera Management Service</dt>
      <dd>
        <p>
        Only available in the Enterprise Edition, the Management Service provides
        monitoring, diagnostic and reporting features for your Hadoop clusters.
        The operation of this service is similar to other Hadoop services, except
        that the Management Service does not belong to a cluster.
      </dd>
      <dt>Metrics</dt>
      <dd>
        <p>
        A metric is a property that can be measured to quantify the state of an
        entity or activity, such as the number of open file descriptors or CPU
        utilization percentage. Full list of metric schema is available through
        Cloudera Manager API /timeseries/schema endpoint.
        <p>
        Cloudera Manager enables retrieving of metric data using a launguage
        called tsquery. Please see tsquery documentation for more details on
        how to write a tsquery.
      </dd>
    </dl>

    <h2>Debugging the API</h2>

    <p>
    You may enable debug logging in Cloudera Manager for API related activities.
    The setting is called "Enable Debugging of API" on the Administration page
    of the Cloudera Manager Admin Console. When enabled, the Cloudera Manager
    server log will contain full traces of all API requests and responses, and
    the debug logging of the request handling. Due to the large volumn of log
    data this may generate, you should enable it only during development.

    <h2>API Usage Examples</h2>

    <p>
    The following examples use curl without a cookie jar, for ease of cut-n-paste.
    But note that it is an inefficient way to authenticate.

    <h3>Explore Around</h3>

    <p>What clusters do we have?
    <code>
  $ curl -u admin:admin 'http://localhost:7180/api/v1/clusters'

  {
    "items" : [ {
      "name" : "Cluster 1 - CDH4",
      "version" : "CDH4"
    }, {
      "name" : "Cluster 2 - CDH3",
      "version" : "CDH3"
    } ]
  }</code>

    <p>This shows the services running in a cluster, with status and health
    information (in the Enterprise Edition). Abridged output:
    <code>
  $ curl -u admin:admin \
  'http://localhost:7180/api/v1/clusters/Cluster%201%20-%20CDH4/services'

  {
    "items" : [ {
      "name" : "hdfs1",
      "type" : "HDFS",
      "configStale" : false,
      "clusterRef" : {
        "clusterName" : "Cluster 1 - CDH4"
      },
      "serviceState" : "STARTED",
      "healthSummary" : "GOOD",
      "healthChecks" : [ {
        "name" : "HDFS_CORRUPT_BLOCKS",
        "summary" : "GOOD"
      }, {
        "name" : "HDFS_DATA_NODES_HEALTHY",
        "summary" : "GOOD"
      }, {
        "name" : "HDFS_MISSING_BLOCKS",
        "summary" : "GOOD"
      }, {
        "name" : "HDFS_HA_NAMENODE_HEALTH",
        "summary" : "GOOD"
      }, {
        "name" : "HDFS_UNDER_REPLICATED_BLOCKS",
        "summary" : "GOOD"
      }, {
        "name" : "HDFS_CANARY_HEALTH",
        "summary" : "GOOD"
      }, {
        "name" : "HDFS_FREE_SPACE_REMAINING",
        "summary" : "GOOD"
      }, {
        "name" : "HDFS_UPGRADE_STATUS",
        "summary" : "GOOD"
      }, {
        "name" : "HDFS_STANDBY_NAMENODES_HEALTHY",
        "summary" : "GOOD"
      } ]
    }, {
      "name" : "mapreduce1",
      "type" : "MAPREDUCE",
      "configStale" : false,
      "clusterRef" : {
        "clusterName" : "Cluster 1 - CDH4"
      },
      "serviceState" : "STARTED",
      "healthSummary" : "GOOD",
      ...</code>

    <p>This shows the custom configuration of <kbd>hdfs1</kbd> and all the role
    types. Config params with default values are excluded, and only shown in
    the "full" view.
    <code>
  $ curl -u admin:admin \
  'http://localhost:7180/api/v1/clusters/Cluster%201%20-%20CDH4/services/hdfs1/config'

  {
    "roleTypeConfigs" : [ {
      "roleType" : "DATANODE",
      "items" : [ {
        "name" : "dfs_data_dir_list",
        "value" : "/dfs/dn"
      } ]
    }, {
      "roleType" : "NAMENODE",
      "items" : [ {
        "name" : "dfs_name_dir_list",
        "value" : "/dfs/nn"
      } ]
    }, {
      "roleType" : "SECONDARYNAMENODE",
      "items" : [ {
        "name" : "fs_checkpoint_dir_list",
        "value" : "/dfs/snn"
      } ]
    }, {
      "roleType" : "BALANCER",
      "items" : [ ]
    }, {
      "roleType" : "GATEWAY",
      "items" : [ ]
    }, {
      "roleType" : "HTTPFS",
      "items" : [ ]
    }, {
      "roleType" : "FAILOVERCONTROLLER",
      "items" : [ ]
    } ],
    "items" : [ {
      "name" : "dfs_ha_fencing_cloudera_manager_secret_key",
      "value" : "K2TCx9h1sk5XXKW05Pa5Qv0MRDwruO"
    }, {
      "name" : "zookeeper_service",
      "value" : "zookeeper1"
    } ]
  }</code>

    <p>The full configuration view shows all parameters with description. Abridged output:
    <code>
  $ curl -u admin:admin \
  'http://localhost:7180/api/v1/clusters/Cluster%201%20-%20CDH4/services/hdfs1/config?view=full'

  {
    "roleTypeConfigs" : [ {
      "roleType" : "DATANODE",
      "items" : [ {
        "name" : "dfs_data_dir_list",
        "value" : "/dfs/dn",
        "required" : true,
        "displayName" : "DataNode Data Directory",
        "description" : "Comma-delimited list of directories on the local file system where the DataNode stores HDFS block data. Typical values are /data/N/dfs/dn for N = 1, 2, 3... These directories should be mounted using the noatime option and the disks should be configured using JBOD. RAID is not recommended.",
        "relatedName" : "dfs.datanode.data.dir",
        "validationState" : "OK"
      }, {
        "name" : "hadoop_metrics_dir",
        "required" : false,
        "displayName" : "Hadoop Metrics Output Directory",
        "description" : "If using FileContext, directory to write metrics to.",
        "validationState" : "OK",
        "default" : "/tmp/metrics"
      }, {
        "name" : "dfs_datanode_http_port",
        "required" : false,
        "displayName" : "DataNode HTTP Web UI Port",
        "description" : "Port for the DataNode HTTP web UI. Combined with the DataNode's hostname to build its HTTP address.",
        "relatedName" : "dfs.datanode.http.address",
        "validationState" : "OK",
        "default" : "50075"
      }, {
      ...</code>

    <h3>Add a New Service and Roles</h3>

    <p>This adds a new HBase service called "my_hbase". The API input is a list
    of services, for bulk operation. Even though the call creates only one service,
    it still passes in a list (with one item). The API returns the newly
    created service.
    <code>
  $ curl -X POST -H "Content-Type:application/json" -u admin:admin \
  -d '{ "items": [ { "name": "my_hbase", "type": "HBASE" } ] }' \
  'http://localhost:7180/api/v1/clusters/Cluster%201%20-%20CDH4/services'

  {
    "items" : [ {
      "name" : "my_hbase",
      "type" : "HBASE",
      "configStale" : false,
      "clusterRef" : {
        "clusterName" : "Cluster 1 - CDH4"
      },
      "serviceState" : "STOPPED"
    } ]
  }</code>

    <p>This creates a Master and a RegionServer roles. The API returns the
    newly created roles.
    <code>
  $ curl -X POST -H "Content-Type:application/json" -u admin:admin \
  -d '{"items": [
        { "name": "master1", "type": "MASTER", "hostRef": { "hostId": "localhost" } },
        { "name": "rs1", "type": "REGIONSERVER", "hostRef": { "hostId": "localhost" } } ] }' \
  'http://localhost:7180/api/v1/clusters/Cluster%201%20-%20CDH4/services/my_hbase/roles'

  {
    "items" : [ {
      "name" : "master1",
      "type" : "MASTER",
      "configStale" : false,
      "hostRef" : {
        "hostId" : "localhost"
      },
      "roleState" : "STOPPED",
      "serviceRef" : {
        "serviceName" : "my_hbase",
        "clusterName" : "Cluster 1 - CDH4"
      }
    }, {
      "name" : "rs1",
      "type" : "REGIONSERVER",
      "configStale" : false,
      "hostRef" : {
        "hostId" : "localhost"
      },
      "roleState" : "STOPPED",
      "serviceRef" : {
        "serviceName" : "my_hbase",
        "clusterName" : "Cluster 1 - CDH4"
      }
    } ]
  </code>

    <h3>Set Configuration</h3>

    <p>This sets the service dependency and HDFS root directory for our newly
    created HBase Service.  The API returns the set of custom configuration.
    <code>
  $ curl -X PUT -H "Content-Type:application/json" -u admin:admin \
  -d '{ "items": [
        { "name": "hdfs_rootdir", "value": "/my_hbase" },
        { "name": "zookeeper_service", "value": "zookeeper1" },
        { "name": "hdfs_service", "value": "hdfs1" } ] }' \
  'http://localhost:7180/api/v1/clusters/Cluster%201%20-%20CDH4/services/my_hbase/config'

  {
    "roleTypeConfigs" : [ {
      "roleType" : "MASTER",
      "items" : [ ]
    }, {
      "roleType" : "REGIONSERVER",
      "items" : [ ]
    }, {
      "roleType" : "GATEWAY",
      "items" : [ ]
    } ],
    "items" : [ {
      "name" : "hdfs_service",
      "value" : "hdfs1"
    }, {
      "name" : "hdfs_rootdir",
      "value" : "/my_hbase"
    }, {
      "name" : "zookeeper_service",
      "value" : "zookeeper1"
    } ]
  }</code>

    <h3>Issue Commands</h3>

    <p>After setting the root directory, we need to create it in HDFS.
    There is an HBase service level command for that.
    As with all API command calls, the issued command runs
    asynchronously. The API returns the command object, which may still be
    active.
    <code>
  $ curl -X POST -u admin:admin \
  'http://localhost:7180/api/v1/clusters/Cluster%201%20-%20CDH4/services/my_hbase/commands/hbaseCreateRoot'

  {
    "id" : 142,
    "name" : "CreateRootDir",
    "startTime" : "2012-05-06T20:56:57.918Z",
    "active" : true,
    "serviceRef" : {
      "serviceName" : "my_hbase",
      "clusterName" : "Cluster 1 - CDH4"
    }
  }</code>

    <p>We can check on the command's status, at the <kbd>/commands</kbd>
    endpoint, to see whether it has finished.
    <code>
  $ curl -u admin:admin 'http://localhost:7180/api/v1/commands/142'

  {
    "id" : 142,
    "name" : "CreateRootDir",
    "startTime" : "2012-05-06T20:56:57.918Z",
    "endTime" : "2012-05-06T20:57:27.172Z",
    "active" : false,
    "success" : true,
    "resultMessage" : "Successfully created HBase root directory.",
    "serviceRef" : {
      "serviceName" : "my_hbase",
      "clusterName" : "Cluster 1 - CDH4"
    },
    "children" : {
      "items" : [ {
        "id" : 141,
        "name" : "CreateDir",
        "startTime" : "2012-05-06T20:56:58.190Z",
        "endTime" : "2012-05-06T20:57:27.171Z",
        "active" : false,
        "success" : true,
        "resultMessage" : "Sucessfully created directory.",
        "roleRef" : {
          "roleName" : "hdfs1-NAMENODE-1",
          "serviceName" : "hdfs1",
          "clusterName" : "Cluster 1 - CDH4"
        }
      } ]
    }
  }</code>

    <p>We now start the new HBase service.
    <code>
  $ curl -X POST -u admin:admin 'http://localhost:7180/api/v1/clusters/Cluster%201%20-%20CDH4/services/my_hbase/commands/start'

  {
    "id" : 145,
    "name" : "Start",
    "startTime" : "2012-05-06T21:00:22.326Z",
    "active" : true,
    "serviceRef" : {
      "serviceName" : "my_hbase",
      "clusterName" : "Cluster 1 - CDH4"
    }
  }</code>

    <p>Again, we poll to check the command's result.
    <code>
  $ curl -u admin:admin 'http://localhost:7180/api/v1/commands/145'

  {
    "id" : 145,
    "name" : "Start",
    "startTime" : "2012-05-06T21:00:22.326Z",
    "endTime" : "2012-05-06T21:00:54.079Z",
    "active" : false,
    "success" : true,
    "resultMessage" : "Service started successfully.",
    "serviceRef" : {
      "serviceName" : "my_hbase",
      "clusterName" : "Cluster 1 - CDH4"
    },
    "children" : {
      "items" : [ {
        "id" : 144,
        "name" : "Start",
        "startTime" : "2012-05-06T21:00:22.375Z",
        "endTime" : "2012-05-06T21:00:48.737Z",
        "active" : false,
        "success" : true,
        "resultMessage" : "Supervisor returned RUNNING",
        "roleRef" : {
          "roleName" : "master1",
          "serviceName" : "my_hbase",
          "clusterName" : "Cluster 1 - CDH4"
        }
      }, {
        "id" : 143,
        "name" : "Start",
        "startTime" : "2012-05-06T21:00:22.356Z",
        "endTime" : "2012-05-06T21:00:54.075Z",
        "active" : false,
        "success" : true,
        "resultMessage" : "Supervisor returned RUNNING",
        "roleRef" : {
          "roleName" : "rs1",
          "serviceName" : "my_hbase",
          "clusterName" : "Cluster 1 - CDH4"
        }
      } ]
    }
  }</code>

    <h3>Querying metric data</h3>

    <p>
    Getting dfs capacity metric data for service HDFS-1.
    <code>
  $ curl -u admin:admin \
  'http://localhost:7180/api/v11/timeseries?query=select%20dfs_capacity,%20dfs_capacity_used,%20dfs_capacity_used_non_hdfs%20where%20entityName=HDFS-1'

  {
    "items" : [ {
      "timeSeries": [ {
        "metadata": {
          "metricName": "dfs_capacity",
          "entityName": "HDFS-1",
          "startTime": "2015-09-17T23:42:22.533Z",
          "endTime": "2015-09-17T23:47:22.533Z",
          "attributes": {
            "clusterName": "Cluster 1",
            "category": "SERVICE",
            "clusterDisplayName": "Cluster 1",
            "active": "true",
            "serviceType": "HDFS",
            "serviceDisplayName": "HDFS-1",
            "version": "CDH 5.7.0",
            "serviceName": "HDFS-1",
            "entityName": "HDFS-1"
          },
          "unitNumerators": [
            "bytes"
          ],
          "unitDenominators": [],
          "expression": "SELECT dfs_capacity WHERE entityName = \"HDFS-1\" AND category = SERVICE",
          "metricCollectionFrequencyMs": 60000,
          "rollupUsed": "RAW"
        },
        "data": [ {
          "timestamp": "2015-09-17T23:43:10.599Z",
          "value": 86909397813,
          "type": "SAMPLE"
        }, {
          "timestamp": "2015-09-17T23:44:10.605Z",
          "value": 86909397813,
          "type": "SAMPLE"
        }, {
          "timestamp": "2015-09-17T23:45:10.608Z",
          "value": 86909397813,
          "type": "SAMPLE"
        }, {
          "timestamp": "2015-09-17T23:46:10.615Z",
          "value": 86909397813,
          "type": "SAMPLE"
        }, {
          "timestamp": "2015-09-17T23:47:15.613Z",
          "value": 86909397813,
          "type": "SAMPLE"
        } ]
      }, {
        "metadata": {
          "metricName": "dfs_capacity_used",
          "entityName": "HDFS-1",
          "startTime": "2015-09-17T23:42:22.533Z",
          "endTime": "2015-09-17T23:47:22.533Z",
          "attributes": {
            "clusterName": "Cluster 1",
            "category": "SERVICE",
            "clusterDisplayName": "Cluster 1",
            "active": "true",
            "serviceType": "HDFS",
            "serviceDisplayName": "HDFS-1",
            "version": "CDH 5.7.0",
            "serviceName": "HDFS-1",
            "entityName": "HDFS-1"
          },
          "unitNumerators": [
            "bytes"
          ],
          "unitDenominators": [],
          "expression": "SELECT dfs_capacity_used WHERE entityName = \"HDFS-1\" AND category = SERVICE",
          "metricCollectionFrequencyMs": 60000,
          "rollupUsed": "RAW"
        },
        "data": [ {
          "timestamp": "2015-09-17T23:43:10.599Z",
          "value": 1728884736,
          "type": "SAMPLE"
        }, {
          "timestamp": "2015-09-17T23:44:10.605Z",
          "value": 1728884736,
          "type": "SAMPLE"
        }, {
          "timestamp": "2015-09-17T23:45:10.608Z",
          "value": 1728884736,
          "type": "SAMPLE"
        }, {
          "timestamp": "2015-09-17T23:46:10.615Z",
          "value": 1728884736,
          "type": "SAMPLE"
        }, {
          "timestamp": "2015-09-17T23:47:15.613Z",
          "value": 1728884736,
          "type": "SAMPLE"
        } ]
      }, {
        "metadata": {
          "metricName": "dfs_capacity_used_non_hdfs",
          "entityName": "HDFS-1",
          "startTime": "2015-09-17T23:42:22.533Z",
          "endTime": "2015-09-17T23:47:22.533Z",
          "attributes": {
            "clusterName": "Cluster 1",
            "category": "SERVICE",
            "clusterDisplayName": "Cluster 1",
            "active": "true",
            "serviceType": "HDFS",
            "serviceDisplayName": "HDFS-1",
            "version": "CDH 5.7.0",
            "serviceName": "HDFS-1",
            "entityName": "HDFS-1"
          },
          "unitNumerators": [
            "bytes"
          ],
          "unitDenominators": [],
          "expression": "SELECT dfs_capacity_used_non_hdfs WHERE entityName = \"HDFS-1\" AND category = SERVICE",
          "metricCollectionFrequencyMs": 60000,
          "rollupUsed": "RAW"
        },
        "data": [ {
          "timestamp": "2015-09-17T23:43:10.599Z",
          "value": 1610609973,
          "type": "SAMPLE"
        }, {
          "timestamp": "2015-09-17T23:44:10.605Z",
          "value": 1610609973,
          "type": "SAMPLE"
        }, {
          "timestamp": "2015-09-17T23:45:10.608Z",
          "value": 1610609973,
          "type": "SAMPLE"
        }, {
          "timestamp": "2015-09-17T23:46:10.615Z",
          "value": 1610609973,
          "type": "SAMPLE"
        }, {
          "timestamp": "2015-09-17T23:47:15.613Z",
          "value": 1610609973,
          "type": "SAMPLE"
        } ]
      } ],
      "warnings": [],
      "timeSeriesQuery": "select dfs_capacity, dfs_capacity_used, dfs_capacity_used_non_hdfs where entityName=HDFS-1"
    } ]</code>

  [/@boilerplate]
[/@file]
